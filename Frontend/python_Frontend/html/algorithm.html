<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm</title>
    <link rel="stylesheet" href="../css/css.css">
   
    <script>
      let currentQuestionIndex = 0; // To track the current question

      function showHint(hintId) {   
        const hint = document.querySelector(`[data-hint="${hintId}"]`);   
        if (hint.style.display === 'none' || hint.style.display === '') {   
           hint.style.display = 'block';   
        } else {   
           hint.style.display = 'none';   
        }   
      }

      // Function to show a specific question based on the index
      function showQuestion(index) {
        const questions = document.querySelectorAll('.qee');
        
        // Hide all questions
        questions.forEach(question => {
          question.style.display = 'none';
        });
        
        // Show the current question
        questions[index].style.display = 'block';

        // Update the current question index
        currentQuestionIndex = index;
      }

      // Function to go to the next question
      function nextQuestion() {
        const questions = document.querySelectorAll('.qee');
        if (currentQuestionIndex < questions.length - 1) {
          showQuestion(currentQuestionIndex + 1);
        }
      }

      // Function to go to the previous question
      function previousQuestion() {
        if (currentQuestionIndex > 0) {
          showQuestion(currentQuestionIndex - 1);
        }
      }

      // Initialize the first question when the page loads
      window.onload = function() {
        showQuestion(currentQuestionIndex);
      };
    </script>
</head>
<body>
    <div class="page-border">
        <div class="inner-border">
            <div class="modal-content" style="display: none;">
                <span class="close"></span>
            </div>
            <h2 style="text-align: center;">Python Algorithms</h2>
            <hr>
            <marquee><b>Topics Covered: </b>
                <strong>Sorting Algorithms</strong>, <strong>Search Algorithms</strong>, <strong>Graph Algorithms</strong>, 
                <strong>Dynamic Programming</strong>, <strong>Greedy Algorithms</strong>, <strong>Divide and Conquer</strong>, 
                <strong>Backtracking</strong>, <strong>Recursive Algorithms</strong>, <strong>Depth-First Search (DFS)</strong>, 
                <strong>Breadth-First Search (BFS)</strong>, <strong>Fibonacci Sequence</strong>, <strong>Merge Sort</strong>, 
                <strong>Quick Sort</strong>, <strong>Dijkstra's Algorithm</strong>, <strong>Knapsack Problem</strong>, 
                <strong>Prim's Algorithm</strong>, <strong>Kruskal's Algorithm</strong>, <strong>Topological Sorting</strong>, 
                <strong>Longest Common Subsequence</strong>, <strong>Dynamic Programming - Fibonacci</strong>, 
                <strong>Bellman-Ford Algorithm</strong>, <strong>A* Search Algorithm</strong>, <strong>Heap Sort</strong>.
            </marquee>
            <hr>
            

            <div class="question-container">

 <!-- Question 1 -->
<div class="qee">
    <div class="que">
        <p>1. Implement the Bubble Sort algorithm to sort a list of numbers in ascending order. Print the sorted list.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint1')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint1" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Bubble sort compares adjacent elements and swaps them if they are in the wrong order.<br>
        2. Start from the beginning of the list and compare adjacent elements. If the left element is greater than the right, swap them.<br>
        3. Repeat this process for all the elements. The largest element will "bubble up" to the end of the list after each pass.<br>
        4. Repeat the process for the remaining unsorted elements until no swaps are needed.<br>
        5. Finally, print the sorted list.
    </div>
    <pre><code>
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]  # Swap the elements

# Example usage
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print(arr)  # This will print the sorted list
</code></pre>
</div>

<!-- Question 2 -->
<div class="qee">
    <div class="que">
        <p>2. Implement the Insertion Sort algorithm to sort a list of numbers in ascending order. Print the sorted list.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint2')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint2" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Insertion sort builds the final sorted array one element at a time.<br>
        2. Start from the second element, compare it with the elements to its left, and insert it in the correct position.<br>
        3. Continue this process for all the elements in the list.<br>
        4. Print the sorted list at the end.
    </div>
    <pre><code>
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

# Example usage
arr = [64, 34, 25, 12, 22, 11, 90]
insertion_sort(arr)
print(arr)  # This will print the sorted list
</code></pre>
</div>

<!-- Question 3 -->
<div class="qee">
    <div class="que">
        <p>3. Implement the Merge Sort algorithm to sort a list of numbers in ascending order. Print the sorted list.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint3')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint3" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Merge sort follows the divide and conquer approach.<br>
        2. First, divide the list into two halves.<br>
        3. Recursively sort each half using merge sort.<br>
        4. Merge the two sorted halves into a single sorted list.<br>
        5. Print the sorted list after the merge.
    </div>
    <pre><code>
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left = arr[:mid]
        right = arr[mid:]

        merge_sort(left)
        merge_sort(right)

        i = j = k = 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                arr[k] = left[i]
                i += 1
            else:
                arr[k] = right[j]
                j += 1
            k += 1

        while i < len(left):
            arr[k] = left[i]
            i += 1
            k += 1

        while j < len(right):
            arr[k] = right[j]
            j += 1
            k += 1

# Example usage
arr = [64, 34, 25, 12, 22, 11, 90]
merge_sort(arr)
print(arr)  # This will print the sorted list
</code></pre>
</div>

<!-- Question 4 -->
<div class="qee">
    <div class="que">
        <p>4. Implement the Quick Sort algorithm to sort a list of numbers in ascending order. Print the sorted list.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint4')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint4" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Quick sort works by selecting a pivot element and partitioning the array into two sub-arrays.<br>
        2. All elements smaller than the pivot go to the left and all elements greater than the pivot go to the right.<br>
        3. Recursively apply the quick sort to the sub-arrays.<br>
        4. Print the sorted list after partitioning and sorting.
    </div>
    <pre><code>
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# Example usage
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = quick_sort(arr)
print(sorted_arr)  # This will print the sorted list
</code></pre>
</div>

<!-- Question 5 -->

<!-- Question 5 -->
<div class="qee">
    <div class="que">
        <p>5. Implement the Fibonacci Search algorithm to find a number in a sorted list. Print the index of the number if found, otherwise print "Not Found".</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint5')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint5" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Fibonacci Search is based on the Fibonacci sequence and works by reducing the search range in a manner similar to Binary Search.<br>
        2. The key idea is to use the Fibonacci numbers to divide the array into smaller subarrays.<br>
        3. Start by finding the largest Fibonacci number less than or equal to the array's length.<br>
        4. Continue checking and reducing the range using Fibonacci numbers until the target is found or the subarray becomes empty.
    </div>
    <pre><code>
def fibonacci_search(arr, target):
    n = len(arr)
    fib_m_minus_2 = 0
    fib_m_minus_1 = 1
    fib = fib_m_minus_1 + fib_m_minus_2

    while fib < n:
        fib_m_minus_2 = fib_m_minus_1
        fib_m_minus_1 = fib
        fib = fib_m_minus_1 + fib_m_minus_2

    offset = -1
    while fib > 1:
        i = min(offset + fib_m_minus_2, n-1)
        if arr[i] < target:
            fib = fib_m_minus_1
            fib_m_minus_1 = fib_m_minus_2
            fib_m_minus_2 = fib - fib_m_minus_1
            offset = i
        elif arr[i] > target:
            fib = fib_m_minus_2
            fib_m_minus_1 -= fib_m_minus_2
            fib_m_minus_2 = fib - fib_m_minus_1
        else:
            return f"Found at index {i}"

    if fib_m_minus_1 and arr[offset + 1] == target:
        return f"Found at index {offset + 1}"
    
    return "Not Found"

# Example usage
arr = [10, 22, 35, 40, 45, 50, 70, 80, 100]
target = 45
print(fibonacci_search(arr, target))  # This will print "Found at index 4"
</code></pre>
</div>

<!-- Question 6 -->
<div class="qee">
    <div class="que">
        <p>6. Implement the Exponential Search algorithm to find a number in a sorted list. Print the index of the number if found, otherwise print "Not Found".</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint6')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint6" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Exponential Search works by first finding the range where the target might exist by doubling the index (exponentially).<br>
        2. Once the range is found, Binary Search is applied to that range.<br>
        3. Start by checking the element at index 1, then at index 2, 4, 8, 16, etc., until the value at the index is greater than or equal to the target.<br>
        4. After determining the range, perform a Binary Search in that range.
    </div>
    <pre><code>
def binary_search(arr, low, high, target):
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1

def exponential_search(arr, target):
    if arr[0] == target:
        return 0
    i = 1
    while i < len(arr) and arr[i] <= target:
        i *= 2
    return binary_search(arr, i // 2, min(i, len(arr) - 1), target)

# Example usage
arr = [10, 22, 35, 40, 45, 50, 70, 80, 100]
target = 45
print(exponential_search(arr, target))  # This will print "4"
</code></pre>
</div>

<!-- Question 7 -->
<div class="qee">
    <div class="que">
        <p>7. Implement the Depth First Search (DFS) algorithm for a graph. Print the nodes visited during the DFS traversal.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint7')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint7" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Depth First Search explores as far down a branch as possible before backtracking.<br>
        2. Use a stack or recursion to implement DFS.<br>
        3. Start at the root node, explore each adjacent node, and continue the process until all nodes are visited.
    </div>
    <pre><code>
def dfs(graph, node, visited=None):
    if visited is None:
        visited = set()
    visited.add(node)
    print(node)
    
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    return visited

# Example usage
graph = {
    "A": ["B", "C"],
    "B": ["D", "E"],
    "C": ["F"],
    "D": [],
    "E": ["F"],
    "F": []
}
dfs(graph, "A")  # This will print the DFS traversal starting from node "A"
</code></pre>
</div>

<!-- Question 8 -->
<div class="qee">
    <div class="que">
        <p>8. Implement the Breadth First Search (BFS) algorithm for a graph. Print the nodes visited during the BFS traversal.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint8')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint8" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Breadth First Search explores all the neighbors at the present depth before moving on to nodes at the next depth level.<br>
        2. Use a queue to implement BFS.<br>
        3. Start at the root node, enqueue it, and then explore its neighbors before moving on to the next nodes in the queue.
    </div>
    <pre><code>
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        node = queue.popleft()
        print(node)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

# Example usage
graph = {
    "A": ["B", "C"],
    "B": ["D", "E"],
    "C": ["F"],
    "D": [],
    "E": ["F"],
    "F": []
}
bfs(graph, "A")  # This will print the BFS traversal starting from node "A"
</code></pre>
</div>
<!-- Question 9 -->
<div class="qee">
    <div class="que">
        <p>9. Write a recursive function to calculate the factorial of a number. Print the result for a given number.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint9')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint9" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. A factorial is the product of all positive integers up to the number.<br>
        2. Use a base case for when the number is 0 or 1 (in which case, return 1).<br>
        3. Otherwise, multiply the number by the factorial of the previous number, i.e., `n * factorial(n-1)`.
    </div>
    <pre><code>
def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)

# Example usage
num = 5
print(factorial(num))  # This will print 120 (5! = 120)
</code></pre>
</div>

<!-- Question 10 -->
<div class="qee">
    <div class="que">
        <p>10. Write a recursive function to find the nth Fibonacci number. Print the result for a given n.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint10')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint10" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. The Fibonacci sequence is defined as: F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1.<br>
        2. Use the base cases where F(0) is 0 and F(1) is 1.<br>
        3. For other numbers, return the sum of the previous two Fibonacci numbers.
    </div>
    <pre><code>
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

# Example usage
n = 6
print(fibonacci(n))  # This will print 8 (the 6th Fibonacci number)
</code></pre>
</div>

<!-- Question 11 -->
<div class="qee">
    <div class="que">
        <p>11. Write a recursive function to compute the sum of digits of a given number. Print the sum of digits.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint11')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint11" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. To find the sum of digits, separate the last digit using modulus (`% 10`).<br>
        2. Use integer division (`// 10`) to remove the last digit.<br>
        3. Add the last digit to the sum of digits of the remaining number.
    </div>
    <pre><code>
def sum_of_digits(n):
    if n == 0:
        return 0
    else:
        return n % 10 + sum_of_digits(n // 10)

# Example usage
num = 123
print(sum_of_digits(num))  # This will print 6 (1 + 2 + 3 = 6)
</code></pre>
</div>

<!-- Question 12 -->
<div class="qee">
    <div class="que">
        <p>12. Write a recursive function to reverse a string. Print the reversed string for a given input string.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint12')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint12" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. The idea is to reverse the rest of the string recursively and then append the first character to it.<br>
        2. Base case: if the string is empty or has one character, return the string.<br>
        3. Otherwise, return the last character plus the reversed substring.
    </div>
    <pre><code>
def reverse_string(s):
    if len(s) == 0:
        return s
    else:
        return reverse_string(s[1:]) + s[0]

# Example usage
input_str = "hello"
print(reverse_string(input_str))  # This will print "olleh"
</code></pre>
</div>

<!-- Question 13 -->
<div class="qee">
    <div class="que">
        <p>13. Write a recursive function to calculate the power of a number (x^n). Print the result for a given base and exponent.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint13')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint13" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. For x^n, the base case is when n equals 0, in which case return 1.<br>
        2. Otherwise, multiply x by the result of the function with exponent n-1, i.e., `x * power(x, n - 1)`.
    </div>
    <pre><code>
def power(x, n):
    if n == 0:
        return 1
    else:
        return x * power(x, n - 1)

# Example usage
base = 2
exponent = 3
print(power(base, exponent))  # This will print 8 (2^3 = 8)
</code></pre>
</div>

<!-- Question 14 -->
<div class="qee">
    <div class="que">
        <p>14. Write a dynamic programming solution to calculate the nth Fibonacci number using memoization. Print the result for a given n.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint14')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint14" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Create a dictionary to store the previously computed Fibonacci numbers.<br>
        2. If the number is already in the dictionary, return it directly.<br>
        3. Otherwise, calculate it recursively and store the result in the dictionary.
    </div>
    <pre><code>
def fibonacci_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo)
    return memo[n]

# Example usage
n = 6
print(fibonacci_memo(n))  # This will print 8 (the 6th Fibonacci number)
</code></pre>
</div>

<!-- Question 15 -->
<div class="qee">
    <div class="que">
        <p>15. Solve the 0/1 Knapsack problem using dynamic programming. Given a list of items with weights and values, find the maximum value that can be carried with a given capacity.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint15')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint15" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Use a 2D array (DP table) to store the maximum values at each weight for each item.<br>
        2. Iterate through each item and check if it can be included by comparing its weight with the current capacity.<br>
        3. Update the table by including or excluding the item based on the maximum value at each step.
    </div>
    <pre><code>
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i-1] <= w:
                dp[i][w] = max(values[i-1] + dp[i-1][w - weights[i-1]], dp[i-1][w])
            else:
                dp[i][w] = dp[i-1][w]
    return dp[n][capacity]

# Example usage
weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]
capacity = 5
print(knapsack(weights, values, capacity))  # This will print 7 (maximum value that can be carried)
</code></pre>
</div>

<!-- Question 16 -->
<div class="qee">
    <div class="que">
        <p>16. Solve the Longest Common Subsequence (LCS) problem using dynamic programming. Given two strings, find the length of their longest common subsequence.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint16')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint16" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Use a 2D array (DP table) to store the length of the LCS at each pair of positions in the two strings.<br>
        2. If the characters match, the LCS length is 1 + the LCS length of the previous characters.<br>
        3. If the characters do not match, the LCS length is the maximum of the lengths of the previous characters.
    </div>
    <pre><code>
def lcs(X, Y):
    m = len(X)
    n = len(Y)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i-1] == Y[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

# Example usage
X = "AGGTAB"
Y = "GXTXAYB"
print(lcs(X, Y))  # This will print 4 (the LCS is "GTAB")
</code></pre>
</div>

<!-- Question 17 -->
<div class="qee">
    <div class="que">
        <p>17. Solve the Coin Change problem using dynamic programming. Given a set of coin denominations and a target amount, find the minimum number of coins needed to make up the amount.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint17')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint17" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Use a 1D array `dp[]` where `dp[i]` represents the minimum number of coins required to make amount `i`.<br>
        2. For each coin denomination, update the dp array by considering the minimum coins needed to form the amount.
    </div>
    <pre><code>
def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

# Example usage
coins = [1, 2, 5]
amount = 11
print(coin_change(coins, amount))  # This will print 3 (using 5 + 5 + 1)
</code></pre>
</div>

<!-- Question 18 -->
<div class="qee">
    <div class="que">
        <p>18. Solve the Minimum Path Sum problem using dynamic programming. Given a grid with non-negative numbers, find the minimum sum path from the top-left corner to the bottom-right corner.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint18')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint18" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Use a 2D array to store the minimum path sum to each cell.<br>
        2. Start from the top-left corner and update each cell based on the minimum sum from the top or left.<br>
        3. Return the value in the bottom-right corner.
    </div>
    <pre><code>
def min_path_sum(grid):
    m = len(grid)
    n = len(grid[0])
    dp = [[0] * n for _ in range(m)]

    dp[0][0] = grid[0][0]
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] + grid[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] + grid[0][j]

    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]

    return dp[m-1][n-1]

# Example usage
grid = [
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1]
]
print(min_path_sum(grid))  # This will print 7 (the minimum path sum)
</code></pre>
</div>
<!-- Question 19 -->
<div class="qee">
    <div class="que">
        <p>19. Solve the Activity Selection problem using a greedy algorithm. Given a list of activities with their start and finish times, select the maximum number of non-overlapping activities.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint19')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint19" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Sort the activities by their finish times.<br>
        2. Select the first activity and then keep selecting the next activity that starts after the last selected one finishes.
    </div>
    <pre><code>
def activity_selection(start, finish):
    n = len(start)
    selected = []

    # Sort activities based on their finish times
    activities = sorted(zip(start, finish), key=lambda x: x[1])
    selected.append(activities[0])

    last_finish = activities[0][1]
    for i in range(1, n):
        if activities[i][0] >= last_finish:
            selected.append(activities[i])
            last_finish = activities[i][1]
    
    return selected

# Example usage
start = [1, 3, 0, 5, 8, 5]
finish = [2, 4, 6, 7, 9, 9]
print(activity_selection(start, finish))  # This will return selected activities
</code></pre>
</div>

<!-- Question 20 -->
<div class="qee">
    <div class="que">
        <p>20. Solve the Fractional Knapsack problem using a greedy algorithm. Given a list of items with values and weights, and a knapsack capacity, find the maximum value that can be obtained by filling the knapsack.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint20')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint20" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Calculate the value-to-weight ratio for each item.<br>
        2. Sort the items by this ratio in descending order.<br>
        3. Pick items from the sorted list, taking as much as possible from the highest ratio items until the knapsack is full.
    </div>
    <pre><code>
def fractional_knapsack(weights, values, capacity):
    n = len(weights)
    items = [(values[i], weights[i], values[i] / weights[i]) for i in range(n)]

    # Sort items by value-to-weight ratio
    items.sort(key=lambda x: x[2], reverse=True)

    total_value = 0
    for value, weight, ratio in items:
        if capacity == 0:
            break
        if weight <= capacity:
            total_value += value
            capacity -= weight
        else:
            total_value += value * (capacity / weight)
            capacity = 0

    return total_value

# Example usage
weights = [10, 40, 20, 30]
values = [60, 40, 100, 120]
capacity = 50
print(fractional_knapsack(weights, values, capacity))  # This will print maximum value
</code></pre>
</div>

<!-- Question 21 -->
<div class="qee">
    <div class="que">
        <p>21. Solve the Job Sequencing problem using a greedy algorithm. Given a set of jobs with deadlines and profits, find the maximum profit by selecting jobs that can be completed before their deadline.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint21')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint21" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Sort jobs in decreasing order of profit.<br>
        2. Iterate through the jobs and schedule each job in the latest available time slot before its deadline.
    </div>
    <pre><code>
def job_sequencing(jobs):
    jobs.sort(key=lambda x: x[2], reverse=True)  # Sort jobs by profit in descending order
    n = len(jobs)
    result = [-1] * n
    slot = [False] * n  # To track free time slots

    total_profit = 0
    for job in jobs:
        for i in range(job[1] - 1, -1, -1):  # Start from the last available slot
            if not slot[i]:
                result[i] = job[0]  # Assign job to slot
                total_profit += job[2]  # Add profit
                slot[i] = True
                break

    return total_profit

# Example usage
jobs = [("Job1", 2, 100), ("Job2", 1, 19), ("Job3", 2, 27), ("Job4", 1, 25), ("Job5", 3, 15)]
print(job_sequencing(jobs))  # This will print the maximum profit
</code></pre>
</div>

<!-- Question 22 -->
<div class="qee">
    <div class="que">
        <p>22. Solve the Minimum Spanning Tree (MST) problem using Prim's Algorithm. Given a graph represented by an adjacency matrix, find the minimum spanning tree.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint22')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint22" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Initialize a set to store the included vertices in the MST.<br>
        2. Use a priority queue to always pick the minimum weight edge that connects a vertex in the MST to a vertex outside the MST.<br>
        3. Repeat this process until all vertices are included in the MST.
    </div>
    <pre><code>
import heapq

def prim(graph, n):
    mst = []
    total_weight = 0
    pq = [(0, 0)]  # Start with the first vertex (arbitrary)
    visited = [False] * n

    while pq:
        weight, u = heapq.heappop(pq)
        if visited[u]:
            continue
        visited[u] = True
        total_weight += weight
        mst.append(u)

        for v, w in enumerate(graph[u]):
            if not visited[v] and w != 0:
                heapq.heappush(pq, (w, v))

    return mst, total_weight

# Example usage
graph = [
    [0, 2, 0, 6, 0],
    [2, 0, 3, 8, 5],
    [0, 3, 0, 0, 7],
    [6, 8, 0, 0, 9],
    [0, 5, 7, 9, 0]
]
n = 5
print(prim(graph, n))  # This will print the MST and total weight
</code></pre>
</div>

<!-- Question 23 -->
<div class="qee">
    <div class="que">
        <p>23. Solve the Huffman Coding problem using a greedy algorithm. Given a set of characters with their frequencies, generate the Huffman codes.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint23')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint23" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Build a priority queue of characters with their frequencies.<br>
        2. Repeatedly extract two nodes with the lowest frequencies, combine them, and insert the resulting node back into the queue.<br>
        3. The resulting tree represents the Huffman codes.
    </div>
    <pre><code>
import heapq

class Node:
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None

    def __lt__(self, other):
        return self.freq < other.freq

def huffman_coding(freq_map):
    heap = [Node(char, freq) for char, freq in freq_map.items()]
    heapq.heapify(heap)

    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        node = Node(None, left.freq + right.freq)
        node.left = left
        node.right = right
        heapq.heappush(heap, node)

    root = heap[0]
    codes = {}

    def generate_codes(node, code):
        if node is None:
            return
        if node.char is not None:
            codes[node.char] = code
        generate_codes(node.left, code + "0")
        generate_codes(node.right, code + "1")

    generate_codes(root, "")
    return codes

# Example usage
freq_map = {'A': 5, 'B': 9, 'C': 12, 'D': 13, 'E': 16, 'F': 45}
print(huffman_coding(freq_map))  # This will print Huffman codes
</code></pre>
</div>

<!-- Question 24 -->
<div class="qee">
    <div class="que">
        <p>24. Solve the N-Queens problem using backtracking. Place N queens on an NxN chessboard so that no two queens threaten each other.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint24')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint24" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start by placing a queen in the first row.<br>
        2. Move to the next row and try placing a queen in each column.<br>
        3. Check for conflicts with previously placed queens (same column, same diagonal).<br>
        4. If placing a queen leads to a conflict, backtrack to the previous row and move the queen to the next column.
    </div>
    <pre><code>
def is_safe(board, row, col, N):
    for i in range(row):
        if board[i][col] == 1:
            return False
        if col - (row - i) >= 0 and board[i][col - (row - i)] == 1:
            return False
        if col + (row - i) < N and board[i][col + (row - i)] == 1:
            return False
    return True

def solve_n_queens(board, row, N):
    if row >= N:
        return True

    for col in range(N):
        if is_safe(board, row, col, N):
            board[row][col] = 1
            if solve_n_queens(board, row + 1, N):
                return True
            board[row][col] = 0  # Backtrack

    return False

def print_board(board, N):
    for row in range(N):
        print(" ".join("Q" if col == 1 else "." for col in board[row]))

N = 4  # Change N for different board sizes
board = [[0] * N for _ in range(N)]
if solve_n_queens(board, 0, N):
    print_board(board, N)
else:
    print("No solution exists.")
</code></pre>
</div>

<!-- Question 25 -->
<div class="qee">
    <div class="que">
        <p>25. Solve the Sudoku puzzle using backtracking. Given a partially filled 9x9 Sudoku board, fill in the empty cells so that each row, column, and 3x3 subgrid contains the digits 1-9.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint25')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint25" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Find an empty cell in the grid.<br>
        2. Try placing digits from 1 to 9 in the cell, ensuring no duplicates in the row, column, or subgrid.<br>
        3. If placing a digit leads to a valid configuration, recursively attempt to fill the next empty cell.<br>
        4. If no valid digit can be placed, backtrack to the previous cell and try a different digit.
    </div>
    <pre><code>
def is_safe(board, row, col, num):
    for i in range(9):
        if board[row][i] == num or board[i][col] == num:
            return False
    start_row, start_col = 3 * (row // 3), 3 * (col // 3)
    for i in range(start_row, start_row + 3):
        for j in range(start_col, start_col + 3):
            if board[i][j] == num:
                return False
    return True

def solve_sudoku(board):
    for row in range(9):
        for col in range(9):
            if board[row][col] == 0:
                for num in range(1, 10):
                    if is_safe(board, row, col, num):
                        board[row][col] = num
                        if solve_sudoku(board):
                            return True
                        board[row][col] = 0  # Backtrack
                return False
    return True

def print_board(board):
    for row in board:
        print(" ".join(str(num) if num != 0 else '.' for num in row))

board = [
    [5, 3, 0, 0, 7, 0, 0, 0, 0],
    [6, 0, 0, 1, 9, 5, 0, 0, 0],
    [0, 9, 8, 0, 0, 0, 0, 6, 0],
    [8, 0, 0, 0, 6, 0, 0, 0, 3],
    [4, 0, 0, 8, 0, 3, 0, 0, 1],
    [7, 0, 0, 0, 2, 0, 0, 0, 6],
    [0, 6, 0, 0, 0, 0, 2, 8, 0],
    [0, 0, 0, 4, 1, 9, 0, 0, 5],
    [0, 0, 0, 0, 8, 0, 0, 7, 9]
]
solve_sudoku(board)
print_board(board)  # This will print the solved Sudoku board
</code></pre>
</div>

<!-- Question 26 -->
<div class="qee">
    <div class="que">
        <p>26. Solve the Subset Sum problem using backtracking. Given a set of integers, find if there is a subset that adds up to a given target sum.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint26')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint26" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start by trying to include the first element in the subset.<br>
        2. Recursively check if the target sum can be achieved by including or excluding each subsequent element.<br>
        3. If at any point the target sum is achieved, return True.<br>
        4. If not, backtrack and try excluding the current element.
    </div>
    <pre><code>
def is_subset_sum(nums, target, index):
    if target == 0:
        return True
    if index == len(nums) or target < 0:
        return False
    
    # Include the current number in the subset
    if is_subset_sum(nums, target - nums[index], index + 1):
        return True
    
    # Exclude the current number and move to the next one
    return is_subset_sum(nums, target, index + 1)

nums = [3, 34, 4, 12, 5, 2]
target = 9
print(is_subset_sum(nums, target, 0))  # This will return True because there is a subset with sum 9
</code></pre>
</div>

<!-- Question 27 -->
<div class="qee">
    <div class="que">
        <p>27. Solve the Permutations problem using backtracking. Given a set of numbers, generate all possible permutations of the numbers.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint27')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint27" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start with an empty permutation.<br>
        2. For each number, try adding it to the permutation.<br>
        3. Recursively build the permutation by including and excluding each number.<br>
        4. When a complete permutation is built, add it to the result.
    </div>
    <pre><code>
def permute(nums):
    def backtrack(start=0):
        if start == len(nums):
            result.append(nums[:])
            return
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]  # Swap
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]  # Backtrack

    result = []
    backtrack()
    return result

nums = [1, 2, 3]
print(permute(nums))  # This will print all permutations of [1, 2, 3]
</code></pre>
</div>
<!-- Question 28 -->
<div class="qee">
    <div class="que">
        <p>28. Implement the Merge Sort algorithm using Divide and Conquer. Sort a list of numbers in ascending order.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint28')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint28" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Divide the list into two halves.<br>
        2. Recursively sort each half.<br>
        3. Merge the two sorted halves back together in a sorted manner.
    </div>
    <pre><code>
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    # Divide the array into two halves
    mid = len(arr) // 2
    left_half = merge_sort(arr[:mid])
    right_half = merge_sort(arr[mid:])
    
    # Merge the sorted halves
    return merge(left_half, right_half)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # Append the remaining elements from either half
    result.extend(left[i:])
    result.extend(right[j:])
    return result

arr = [38, 27, 43, 3, 9, 82, 10]
print(merge_sort(arr))  # This will print the sorted array
</code></pre>
</div>

<!-- Question 29 -->
<div class="qee">
    <div class="que">
        <p>29. Implement the Quick Sort algorithm using Divide and Conquer. Sort a list of numbers in ascending order.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint29')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint29" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Choose a pivot element from the list.<br>
        2. Partition the list into two sublists, one with elements smaller than the pivot and one with elements greater than the pivot.<br>
        3. Recursively apply Quick Sort to the sublists.
    </div>
    <pre><code>
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

arr = [38, 27, 43, 3, 9, 82, 10]
print(quick_sort(arr))  # This will print the sorted array
</code></pre>
</div>

<!-- Question 30 -->
<div class="qee">
    <div class="que">
        <p>30. Implement the Binary Search algorithm using Divide and Conquer. Given a sorted list of numbers, find the index of a target number.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint30')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint30" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start with the middle element of the sorted list.<br>
        2. If the target is equal to the middle element, return the index.<br>
        3. If the target is smaller, recursively search the left half.<br>
        4. If the target is larger, recursively search the right half.
    </div>
    <pre><code>
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1

arr = [3, 9, 10, 27, 38, 43, 82]
target = 27
print(binary_search(arr, target))  # This will print the index of target
</code></pre>
</div>

<!-- Question 31 -->
<div class="qee">
    <div class="que">
        <p>31. Implement the Strassen's Matrix Multiplication algorithm using Divide and Conquer. Multiply two matrices efficiently.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint31')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint31" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Divide each matrix into 4 submatrices.<br>
        2. Recursively compute 7 products using combinations of the submatrices.<br>
        3. Combine the products to form the resulting matrix.
    </div>
    <pre><code>
import numpy as np

def strassen(A, B):
    if len(A) == 1:
        return A * B
    
    mid = len(A) // 2
    A11, A12, A21, A22 = A[:mid, :mid], A[:mid, mid:], A[mid:, :mid], A[mid:, mid:]
    B11, B12, B21, B22 = B[:mid, :mid], B[:mid, mid:], B[mid:, :mid], B[mid:, mid:]
    
    M1 = strassen(A11 + A22, B11 + B22)
    M2 = strassen(A21 + A22, B11)
    M3 = strassen(A11, B12 - B22)
    M4 = strassen(A22, B21 - B11)
    M5 = strassen(A11 + A12, B22)
    M6 = strassen(A21 - A11, B11 + B12)
    M7 = strassen(A12 - A22, B21 + B22)

    C11 = M1 + M4 - M5 + M7
    C12 = M3 + M5
    C21 = M2 + M4
    C22 = M1 - M2 + M3 + M6
    
    C = np.vstack((np.hstack((C11, C12)), np.hstack((C21, C22))))
    return C

A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])
print(strassen(A, B))  # This will print the matrix product of A and B
</code></pre>
</div>

<!-- Question 32 -->
<div class="qee">
    <div class="que">
        <p>32. Implement the Closest Pair of Points problem using Divide and Conquer. Given a set of points, find the pair of points that are closest to each other.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint32')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint32" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Divide the points into two halves based on the x-coordinates.<br>
        2. Recursively find the closest pair in each half.<br>
        3. Find the closest pair that crosses the dividing line.
    </div>
    <pre><code>
import math

def closest_pair(points):
    def dist(p1, p2):
        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)
    
    def closest_pair_rec(points_sorted_by_x, points_sorted_by_y):
        if len(points_sorted_by_x) <= 3:
            return brute_force_closest_pair(points_sorted_by_x)
        
        mid = len(points_sorted_by_x) // 2
        left_points = points_sorted_by_x[:mid]
        right_points = points_sorted_by_x[mid:]

        midpoint = points_sorted_by_x[mid][0]
        left_y = [p for p in points_sorted_by_y if p[0] <= midpoint]
        right_y = [p for p in points_sorted_by_y if p[0] > midpoint]
        
        left_closest = closest_pair_rec(left_points, left_y)
        right_closest = closest_pair_rec(right_points, right_y)
        closest = min(left_closest, right_closest, key=lambda x: x[2])

        strip_closest = closest_pair_strip(points_sorted_by_x, points_sorted_by_y, closest[2])
        return min(closest, strip_closest, key=lambda x: x[2])
    
    return closest_pair_rec(points, sorted(points, key=lambda x: x[1]))

def brute_force_closest_pair(points):
    min_dist = float('inf')
    closest = None
    for i in range(len(points)):
        for j in range(i + 1, len(points)):
            d = dist(points[i], points[j])
            if d < min_dist:
                min_dist = d
                closest = (points[i], points[j], d)
    return closest

def closest_pair_strip(points_sorted_by_x, points_sorted_by_y, delta):
    # Function for checking closest pair in the strip
    pass

points = [(0, 0), (1, 1), (4, 4), (6, 6)]
print(closest_pair(points))  # This will print the closest pair of points
</code></pre>
</div>
<!-- Question 33 -->
<div class="qee">
    <div class="que">
        <p>33. Implement the Depth-First Search (DFS) algorithm for a graph. Traverse the graph starting from a given node.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint33')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint33" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. DFS explores as far as possible along a branch before backtracking.<br>
        2. Use a stack (either explicit or via recursion) to explore each node.<br>
        3. Mark each node as visited to avoid cycles.
    </div>
    <pre><code>
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start)
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}
dfs(graph, 'A')  # This will print the DFS traversal starting from 'A'
</code></pre>
</div>

<!-- Question 34 -->
<div class="qee">
    <div class="que">
        <p>34. Implement the Breadth-First Search (BFS) algorithm for a graph. Traverse the graph level by level starting from a given node.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint34')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint34" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. BFS explores the graph level by level, starting from the root node.<br>
        2. Use a queue to keep track of nodes to explore.<br>
        3. Mark each node as visited to avoid cycles.
    </div>
    <pre><code>
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    
    while queue:
        node = queue.popleft()
        if node not in visited:
            visited.add(node)
            print(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    queue.append(neighbor)
    
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}
bfs(graph, 'A')  # This will print the BFS traversal starting from 'A'
</code></pre>
</div>

<!-- Question 35 -->
<div class="qee">
    <div class="que">
        <p>35. Implement Dijkstra's algorithm to find the shortest path from a source node to all other nodes in a weighted graph.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint35')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint35" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start by assigning a tentative distance value to every node: set it to 0 for the initial node and infinity for all other nodes.<br>
        2. Set the initial node as current.<br>
        3. For the current node, consider all of its unvisited neighbors and calculate their tentative distances.<br>
        4. After visiting all the neighbors, mark the current node as visited and move to the next unvisited node with the smallest tentative distance.
    </div>
    <pre><code>
import heapq

def dijkstra(graph, start):
    # Create a priority queue and dictionary for distances
    queue = [(0, start)]
    distances = {start: 0}
    visited = set()
    
    while queue:
        current_distance, current_node = heapq.heappop(queue)
        if current_node in visited:
            continue
        visited.add(current_node)
        
        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight
            if neighbor not in distances or distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(queue, (distance, neighbor))
    
    return distances

graph = {
    'A': [('B', 1), ('C', 4)],
    'B': [('A', 1), ('C', 2), ('D', 5)],
    'C': [('A', 4), ('B', 2), ('D', 1)],
    'D': [('B', 5), ('C', 1)]
}
print(dijkstra(graph, 'A'))  # This will print the shortest distances from 'A' to all other nodes
</code></pre>
</div>

<!-- Question 36 -->
<div class="qee">
    <div class="que">
        <p>36. Implement the Bellman-Ford algorithm to find the shortest path from a source node to all other nodes in a weighted graph (with possible negative weights).</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint36')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint36" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Initialize the distance to the source node as 0 and to all other nodes as infinity.<br>
        2. Relax all edges repeatedly for (V-1) times, where V is the number of vertices.<br>
        3. If you can still relax an edge, it indicates a negative weight cycle.
    </div>
    <pre><code>
def bellman_ford(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    
    for _ in range(len(graph) - 1):
        for node in graph:
            for neighbor, weight in graph[node]:
                if distances[node] + weight < distances[neighbor]:
                    distances[neighbor] = distances[node] + weight
    
    # Check for negative-weight cycles
    for node in graph:
        for neighbor, weight in graph[node]:
            if distances[node] + weight < distances[neighbor]:
                print("Graph contains negative weight cycle")
                return None
    
    return distances

graph = {
    'A': [('B', 1), ('C', 4)],
    'B': [('A', 1), ('C', 2), ('D', 5)],
    'C': [('A', 4), ('B', 2), ('D', 1)],
    'D': [('B', 5), ('C', 1)]
}
print(bellman_ford(graph, 'A'))  # This will print the shortest distances from 'A' to all other nodes
</code></pre>
</div>

<!-- Question 37 -->
<div class="qee">
    <div class="que">
        <p>37. Implement the Floyd-Warshall algorithm to find the shortest paths between all pairs of nodes in a weighted graph.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint37')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint37" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Initialize a distance matrix, where the distance between each node and itself is 0 and the distance between two nodes is infinity if they are not directly connected.<br>
        2. Iteratively update the matrix by checking if a path through another node provides a shorter path.
    </div>
    <pre><code>
def floyd_warshall(graph):
    nodes = list(graph.keys())
    dist = {node: {other: float('inf') for other in nodes} for node in nodes}
    
    for node in nodes:
        dist[node][node] = 0
        for neighbor, weight in graph[node]:
            dist[node][neighbor] = weight
    
    for k in nodes:
        for i in nodes:
            for j in nodes:
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    return dist

graph = {
    'A': [('B', 1), ('C', 4)],
    'B': [('A', 1), ('C', 2), ('D', 5)],
    'C': [('A', 4), ('B', 2), ('D', 1)],
    'D': [('B', 5), ('C', 1)]
}
print(floyd_warshall(graph))  # This will print the shortest distances between all pairs of nodes
</code></pre>
</div>
<!-- Question 38 -->
<div class="qee">
    <div class="que">
        <p>38. Implement Inorder, Preorder, and Postorder Tree Traversals for a binary tree.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint38')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint38" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Implement recursive functions for Inorder, Preorder, and Postorder traversals.<br>
        2. In Inorder, the order is: Left, Root, Right.<br>
        3. In Preorder, the order is: Root, Left, Right.<br>
        4. In Postorder, the order is: Left, Right, Root.
    </div>
    <pre><code>
class TreeNode:
    def __init__(self, value):
        self.val = value
        self.left = None
        self.right = None

def inorder(root):
    if root:
        inorder(root.left)
        print(root.val)
        inorder(root.right)

def preorder(root):
    if root:
        print(root.val)
        preorder(root.left)
        preorder(root.right)

def postorder(root):
    if root:
        postorder(root.left)
        postorder(root.right)
        print(root.val)

# Example
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print("Inorder Traversal:")
inorder(root)

print("\nPreorder Traversal:")
preorder(root)

print("\nPostorder Traversal:")
postorder(root)
</code></pre>
</div>

<!-- Question 39 -->
<div class="qee">
    <div class="que">
        <p>39. Implement the Knuth-Morris-Pratt (KMP) Algorithm for pattern matching in a string.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint39')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint39" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Build the prefix table (LPS array) for the pattern.<br>
        2. Use the LPS array to skip unnecessary comparisons while matching the pattern in the text.
    </div>
    <pre><code>
def compute_lps(pattern):
    lps = [0] * len(pattern)
    length = 0
    i = 1
    while i < len(pattern):
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length-1]
            else:
                lps[i] = 0
                i += 1
    return lps

def kmp_search(text, pattern):
    lps = compute_lps(pattern)
    i = j = 0
    while i < len(text):
        if pattern[j] == text[i]:
            i += 1
            j += 1
        if j == len(pattern):
            print(f"Pattern found at index {i-j}")
            j = lps[j-1]
        elif i < len(text) and pattern[j] != text[i]:
            if j != 0:
                j = lps[j-1]
            else:
                i += 1

# Example
text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
kmp_search(text, pattern)
</code></pre>
</div>

<!-- Question 40 -->
<div class="qee">
    <div class="que">
        <p>40. Implement the Rabin-Karp Algorithm for pattern matching in a string.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint40')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint40" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Compute the hash of the pattern and the initial substring of the text.<br>
        2. Slide the window across the text and compute the hash of the next substring.<br>
        3. If the hashes match, perform a direct comparison of the pattern and the substring.
    </div>
    <pre><code>
def rabin_karp(text, pattern):
    d = 256  # number of characters in the input alphabet
    q = 101  # a prime number
    m = len(pattern)
    n = len(text)
    p = 0  # hash value for pattern
    t = 0  # hash value for text
    h = 1

    # Calculate the hash value for pattern and the first window of text
    for i in range(m-1):
        h = (h * d) % q

    for i in range(m):
        p = (d * p + ord(pattern[i])) % q
        t = (d * t + ord(text[i])) % q

    # Slide the pattern over the text one by one
    for i in range(n - m + 1):
        if p == t:
            if text[i:i + m] == pattern:
                print(f"Pattern found at index {i}")
        if i < n - m:
            t = (d * (t - ord(text[i]) * h) + ord(text[i + m])) % q
            if t < 0:
                t += q

# Example
text = "GEEKS FOR GEEKS"
pattern = "GEEKS"
rabin_karp(text, pattern)
</code></pre>
</div>

<!-- Question 41 -->
<div class="qee">
    <div class="que">
        <p>41. Implement the Sieve of Eratosthenes algorithm to find all prime numbers up to a given number N.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint41')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint41" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Create a list to mark whether each number is prime.<br>
        2. Starting from 2, mark all multiples of each number as non-prime.
    </div>
    <pre><code>
def sieve_of_eratosthenes(n):
    primes = [True] * (n+1)
    p = 2
    while (p * p <= n):
        if primes[p] == True:
            for i in range(p * p, n+1, p):
                primes[i] = False
        p += 1
    primes[0], primes[1] = False, False
    return [p for p in range(n+1) if primes[p]]

# Example
n = 30
print(sieve_of_eratosthenes(n))  # This will print all primes up to 30
</code></pre>
</div>

<!-- Question 42 -->
<div class="qee">
    <div class="que">
        <p>42. Implement Ford-Fulkerson Algorithm for finding the maximum flow in a flow network.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint42')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint42" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Use a residual graph to track available capacity.<br>
        2. Repeatedly find augmenting paths in the residual graph.<br>
        3. Add the flow along the augmenting path to the maximum flow.
    </div>
    <pre><code>
def bfs(capacity, source, sink, parent):
    visited = [False] * len(capacity)
    queue = [source]
    visited[source] = True
    
    while queue:
        u = queue.pop(0)
        for v in range(len(capacity)):
            if not visited[v] and capacity[u][v] > 0:
                queue.append(v)
                visited[v] = True
                parent[v] = u
                if v == sink:
                    return True
    return False

def ford_fulkerson(capacity, source, sink):
    parent = [-1] * len(capacity)
    max_flow = 0

    while bfs(capacity, source, sink, parent):
        path_flow = float('Inf')
        s = sink
        while s != source:
            path_flow = min(path_flow, capacity[parent[s]][s])
            s = parent[s]
        
        max_flow += path_flow

        v = sink
        while v != source:
            u = parent[v]
            capacity[u][v] -= path_flow
            capacity[v][u] += path_flow
            v = parent[v]

    return max_flow

# Example: Flow network
capacity = [
    [0, 16, 13, 0, 0, 0],
    [0, 0, 10, 12, 0, 0],
    [0, 4, 0, 0, 14, 0],
    [0, 0, 9, 0, 0, 20],
    [0, 0, 0, 7, 0, 4],
    [0, 0, 0, 0, 0, 0]
]
source = 0
sink = 5
print(ford_fulkerson(capacity, source, sink))  # Output: Maximum Flow
</code></pre>
</div>

<!-- Question 43 -->
<div class="qee">
    <div class="que">
        <p>43. Implement Boyer-Moore Algorithm for string matching.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint43')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint43" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Preprocess the pattern to create the bad-character shift and good-suffix shift tables.<br>
        2. Use these tables to efficiently skip sections of the text during the search.
    </div>
    <pre><code>
def boyer_moore(text, pattern):
    m = len(pattern)
    n = len(text)
    
    bad_char = [-1] * 256
    for i in range(m):
        bad_char[ord(pattern[i])] = i
    
    s = 0
    while s <= n - m:
        j = m - 1
        while j >= 0 and pattern[j] == text[s + j]:
            j -= 1
        if j < 0:
            print(f"Pattern found at index {s}")
            s += (m - bad_char[ord(text[s + m])] if s + m < n else 1)
        else:
            s += max(1, j - bad_char[ord(text[s + j])])
    
# Example
text = "ABAAABCDABCABCDABDE"
pattern = "ABCDABD"
boyer_moore(text, pattern)
</code></pre>
</div>
<!-- Question 44 -->
<div class="qee">
    <div class="que">
        <p>44. Implement Bucket Sort for sorting an array of floating-point numbers.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint44')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint44" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Create empty buckets and distribute the elements of the array into those buckets.<br>
        2. Sort each bucket individually using a sorting algorithm.<br>
        3. Concatenate all the sorted buckets to get the final sorted array.
    </div>
    <pre><code>
def bucket_sort(arr):
    if len(arr) == 0:
        return arr

    min_value = min(arr)
    max_value = max(arr)
    
    bucket_count = len(arr)
    buckets = [[] for _ in range(bucket_count)]

    # Put array elements into different buckets
    for num in arr:
        index = int((num - min_value) / (max_value - min_value) * (bucket_count - 1))
        buckets[index].append(num)

    # Sort each bucket and concatenate
    for i in range(bucket_count):
        buckets[i].sort()

    sorted_arr = []
    for i in range(bucket_count):
        sorted_arr.extend(buckets[i])

    return sorted_arr

# Example
arr = [0.42, 0.32, 0.23, 0.56, 0.71, 0.85]
print(bucket_sort(arr))  # Output: [0.23, 0.32, 0.42, 0.56, 0.71, 0.85]
</code></pre>
</div>

<!-- Question 45 -->
<div class="qee">
    <div class="que">
        <p>45. Implement Radix Sort for sorting an array of non-negative integers.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint45')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint45" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Perform counting sort for each digit (starting from the least significant digit).<br>
        2. Use stable sorting on each digit.
    </div>
    <pre><code>
def counting_sort(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10

    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1

    for i in range(1, 10):
        count[i] += count[i - 1]

    i = n - 1
    while i >= 0:
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1

    for i in range(n):
        arr[i] = output[i]

def radix_sort(arr):
    max_val = max(arr)
    exp = 1
    while max_val // exp > 0:
        counting_sort(arr, exp)
        exp *= 10
    return arr

# Example
arr = [170, 45, 75, 90, 802, 24, 2, 66]
print(radix_sort(arr))  # Output: [2, 24, 45, 66, 75, 90, 170, 802]
</code></pre>
</div>

<!-- Question 46 -->
<div class="qee">
    <div class="que">
        <p>46. Implement Merge Sort for sorting an array.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint46')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint46" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Divide the array into two halves.<br>
        2. Recursively sort each half.<br>
        3. Merge the two sorted halves into a single sorted array.
    </div>
    <pre><code>
def merge(arr1, arr2):
    result = []
    i = j = 0
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            result.append(arr1[i])
            i += 1
        else:
            result.append(arr2[j])
            j += 1
    result.extend(arr1[i:])
    result.extend(arr2[j:])
    return result

def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

# Example
arr = [38, 27, 43, 3, 9, 82, 10]
print(merge_sort(arr))  # Output: [3, 9, 10, 27, 38, 43, 82]
</code></pre>
</div>

<!-- Question 47 -->
<div class="qee">
    <div class="que">
        <p>47. Implement Quick Sort for sorting an array.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint47')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint47" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Select a pivot element.<br>
        2. Partition the array into two subarrays: one with elements smaller than the pivot and one with elements larger.<br>
        3. Recursively sort the subarrays.
    </div>
    <pre><code>
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# Example
arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))  # Output: [1, 1, 2, 3, 6, 8, 10]
</code></pre>
</div>

<!-- Question 48 -->
<div class="qee">
    <div class="que">
        <p>48. Implement Heap Sort for sorting an array.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint48')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint48" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Build a max heap from the input array.<br>
        2. Swap the root (max) with the last element of the heap.<br>
        3. Reduce the heap size and heapify the root.
    </div>
    <pre><code>
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    if left < n and arr[i] < arr[left]:
        largest = left
    if right < n and arr[largest] < arr[right]:
        largest = right
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
    return arr

# Example
arr = [12, 11, 13, 5, 6, 7]
print(heap_sort(arr))  # Output: [5, 6, 7, 11, 12, 13]
</code></pre>
</div>

<!-- Question 49 -->
<div class="qee">
    <div class="que">
        <p>49. Implement Insertion Sort for sorting an array.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint49')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint49" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start with the second element.<br>
        2. Compare it with the elements before it and insert it in the correct position.
    </div>
    <pre><code>
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# Example
arr = [12, 11, 13, 5, 6]
print(insertion_sort(arr))  # Output: [5, 6, 11, 12, 13]
</code></pre>
</div>

<!-- Question 50 -->
<div class="qee">
    <div class="que">
        <p>50. Implement Selection Sort for sorting an array.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint50')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint50" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start with the first element.<br>
        2. Find the smallest element in the unsorted part of the array.<br>
        3. Swap it with the first element of the unsorted part.
    </div>
    <pre><code>
def selection_sort(arr):
    for i in range(len(arr)):
        min_index = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr

# Example
arr = [64, 25, 12, 22, 11]
print(selection_sort(arr))  # Output: [11, 12, 22, 25, 64]
</code></pre>
</div>
<!-- Question 51 -->
<div class="qee">
    <div class="que">
        <p>51. Implement Shell Sort for sorting an array.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint51')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint51" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start by sorting elements that are far apart.<br>
        2. Reduce the gap between elements as the algorithm progresses.
    </div>
    <pre><code>
def shell_sort(arr):
    n = len(arr)
    gap = n // 2
    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap //= 2
    return arr

# Example
arr = [5, 2, 9, 1, 5, 6]
print(shell_sort(arr))  # Output: [1, 2, 5, 5, 6, 9]
</code></pre>
</div>

<!-- Question 52 -->
<div class="qee">
    <div class="que">
        <p>52. Implement Counting Sort for sorting an array of non-negative integers.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint52')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint52" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Count the frequency of each element.<br>
        2. Use the frequency to determine the position of each element in the sorted array.
    </div>
    <pre><code>
def counting_sort(arr):
    max_val = max(arr)
    count = [0] * (max_val + 1)
    output = [0] * len(arr)

    for num in arr:
        count[num] += 1

    for i in range(1, len(count)):
        count[i] += count[i - 1]

    for i in range(len(arr) - 1, -1, -1):
        output[count[arr[i]] - 1] = arr[i]
        count[arr[i]] -= 1

    return output

# Example
arr = [4, 2, 2, 8, 3, 3, 1]
print(counting_sort(arr))  # Output: [1, 2, 2, 3, 3, 4, 8]
</code></pre>
</div>

<!-- Question 53 -->
<div class="qee">
    <div class="que">
        <p>53. Implement Binary Search to find an element in a sorted array.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint53')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint53" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start by comparing the middle element with the target.<br>
        2. If the target is smaller, discard the right half; otherwise, discard the left half.<br>
        3. Repeat the process until the element is found or the search space is empty.
    </div>
    <pre><code>
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1  # Element not found

# Example
arr = [1, 3, 5, 7, 9, 11, 13, 15]
print(binary_search(arr, 7))  # Output: 3
</code></pre>
</div>

<!-- Question 54 -->
<div class="qee">
    <div class="que">
        <p>54. Implement Fibonacci Sequence (Recursive & Iterative)</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint54')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint54" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. The Fibonacci sequence is defined by: F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1.<br>
        2. Implement a recursive function and an iterative version to find the nth Fibonacci number.
    </div>
    <pre><code>
# Recursive
def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

# Iterative
def fibonacci_iterative(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a

# Example
print(fibonacci_recursive(5))  # Output: 5
print(fibonacci_iterative(5))  # Output: 5
</code></pre>
</div>

<!-- Question 55 -->
<div class="qee">
    <div class="que">
        <p>55. Implement the Knapsack Problem using Dynamic Programming.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint55')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint55" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Define a 2D DP array where dp[i][w] represents the maximum value achievable with the first i items and a capacity of w.<br>
        2. Recursively solve subproblems and fill the DP table.
    </div>
    <pre><code>
def knapsack(weights, values, W):
    n = len(weights)
    dp = [[0] * (W + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(1, W + 1):
            if weights[i - 1] <= w:
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]

    return dp[n][W]

# Example
weights = [1, 2, 3]
values = [10, 20, 30]
W = 5
print(knapsack(weights, values, W))  # Output: 50
</code></pre>
</div>

<!-- Question 56 -->
<div class="qee">
    <div class="que">
        <p>56. Implement Longest Common Subsequence (LCS) using Dynamic Programming.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint56')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint56" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Create a DP table where dp[i][j] represents the LCS length of the first i characters of string X and the first j characters of string Y.<br>
        2. Use the recursive relation to fill the table.
    </div>
    <pre><code>
def lcs(X, Y):
    m, n = len(X), len(Y)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]

# Example
X = "AGGTAB"
Y = "GXTXAYB"
print(lcs(X, Y))  # Output: 4
</code></pre>
</div>
<!-- Question 57 -->
<div class="qee">
    <div class="que">
        <p>57. Implement Longest Increasing Subsequence using Dynamic Programming.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint57')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint57" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Use dynamic programming to store the length of the longest increasing subsequence at each index.<br>
        2. For each element, check all previous elements and update the length accordingly.
    </div>
    <pre><code>
def longest_increasing_subsequence(arr):
    n = len(arr)
    dp = [1] * n  # Start with each element being a subsequence of length 1

    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)

# Example
arr = [10, 22, 9, 33, 21, 50, 41, 60, 80]
print(longest_increasing_subsequence(arr))  # Output: 6
</code></pre>
</div>

<!-- Question 58 -->
<div class="qee">
    <div class="que">
        <p>58. Implement Matrix Chain Multiplication using Dynamic Programming.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint58')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint58" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Use dynamic programming to compute the minimum number of scalar multiplications.<br>
        2. Define a DP table to store the minimum cost for multiplying submatrices.
    </div>
    <pre><code>
def matrix_chain_multiplication(dimensions):
    n = len(dimensions) - 1
    dp = [[0] * n for _ in range(n)]

    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            dp[i][j] = float('inf')
            for k in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + dimensions[i] * dimensions[k + 1] * dimensions[j + 1])

    return dp[0][n - 1]

# Example
dimensions = [1, 2, 3, 4]
print(matrix_chain_multiplication(dimensions))  # Output: 18
</code></pre>
</div>

<!-- Question 59 -->
<div class="qee">
    <div class="que">
        <p>59. Implement Coin Change Problem using Dynamic Programming.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint59')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint59" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Use dynamic programming to store the minimum number of coins needed to make each amount.<br>
        2. Update the DP table by checking each coin denomination.
    </div>
    <pre><code>
def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # No coins needed to make 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

# Example
coins = [1, 2, 5]
amount = 11
print(coin_change(coins, amount))  # Output: 3
</code></pre>
</div>

<!-- Question 60 -->
<div class="qee">
    <div class="que">
        <p>60. Implement Subset Sum Problem using Dynamic Programming.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint60')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint60" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Use dynamic programming to store whether a subset sum is possible for each value.<br>
        2. Update the DP table by checking if a subset sum can be formed using the current element.
    </div>
    <pre><code>
def subset_sum(arr, target):
    n = len(arr)
    dp = [[False] * (target + 1) for _ in range(n + 1)]

    for i in range(n + 1):
        dp[i][0] = True  # A sum of 0 is always possible (empty subset)

    for i in range(1, n + 1):
        for j in range(1, target + 1):
            if arr[i - 1] <= j:
                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]
            else:
                dp[i][j] = dp[i - 1][j]

    return dp[n][target]

# Example
arr = [3, 34, 4, 12, 5, 2]
target = 9
print(subset_sum(arr, target))  # Output: True
</code></pre>
</div>

<!-- Question 61 -->
<div class="qee">
    <div class="que">
        <p>61. Implement Hamiltonian Path using Backtracking.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint61')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint61" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start with a vertex and try to visit all other vertices exactly once.<br>
        2. Use backtracking to explore all possible paths and check if a Hamiltonian path exists.
    </div>
    <pre><code>
def is_safe(graph, path, pos, v):
    if graph[path[pos - 1]][v] == 0:
        return False
    if v in path:
        return False
    return True

def hamiltonian_path(graph, path, pos):
    if pos == len(graph):
        return True

    for v in range(1, len(graph)):
        if is_safe(graph, path, pos, v):
            path[pos] = v
            if hamiltonian_path(graph, path, pos + 1):
                return True
            path[pos] = -1
    return False

def solve_hamiltonian_path(graph):
    path = [-1] * len(graph)
    path[0] = 0
    if hamiltonian_path(graph, path, 1):
        return path
    return None

# Example
graph = [
    [0, 1, 0, 1],
    [1, 0, 1, 1],
    [0, 1, 0, 1],
    [1, 1, 1, 0]
]
print(solve_hamiltonian_path(graph))  # Output: A valid Hamiltonian Path (e.g. [0, 1, 2, 3])
</code></pre>
</div>

<!-- Question 62 -->
<div class="qee">
    <div class="que">
        <p>62. Implement Traveling Salesman Problem using Backtracking.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint62')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint62" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Try all possible permutations of the cities.<br>
        2. Calculate the total distance for each permutation and return the minimum distance.
    </div>
    <pre><code>
import itertools

def traveling_salesman(graph):
    n = len(graph)
    cities = list(range(n))
    min_path = None
    min_dist = float('inf')

    for perm in itertools.permutations(cities[1:]):
        perm = [cities[0]] + list(perm)
        dist = sum(graph[perm[i]][perm[i + 1]] for i in range(n - 1))
        dist += graph[perm[-1]][perm[0]]  # Return to the starting city
        if dist < min_dist:
            min_dist = dist
            min_path = perm

    return min_path, min_dist

# Example
graph = [
    [0, 10, 15, 20, 25],
    [10, 0, 35, 25, 30],
    [15, 35, 0, 30, 5],
    [20, 25, 30, 0, 15],
    [25, 30, 5, 15, 0]
]
print(traveling_salesman(graph))  # Output: A valid path and the minimum distance
</code></pre>
</div>
<!-- Question 63 -->
<div class="qee">
    <div class="que">
        <p>63. Implement the KMP Algorithm (Knuth-Morris-Pratt) for String Matching.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint63')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint63" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Create a prefix function (also called LPS - Longest Prefix Suffix) to preprocess the pattern.<br>
        2. Use the prefix function to avoid unnecessary comparisons while searching for the pattern in the text.
    </div>
    <pre><code>
def KMP_search(text, pattern):
    def compute_lps(pattern):
        lps = [0] * len(pattern)
        length = 0
        i = 1
        while i < len(pattern):
            if pattern[i] == pattern[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length - 1]
                else:
                    lps[i] = 0
                    i += 1
        return lps

    lps = compute_lps(pattern)
    i = 0
    j = 0
    while i < len(text):
        if text[i] == pattern[j]:
            i += 1
            j += 1
        if j == len(pattern):
            return i - j  # Match found at index (i - j)
        elif i < len(text) and text[i] != pattern[j]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    return -1  # No match found

# Example
text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
print(KMP_search(text, pattern))  # Output: 10
</code></pre>
</div>

<!-- Question 64 -->
<div class="qee">
    <div class="que">
        <p>64. Implement the Rabin-Karp Algorithm for String Matching.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint64')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint64" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Use a hash function to generate a hash for the pattern and for each substring of the text.<br>
        2. Compare the hashes first, then check the characters only if the hashes match.
    </div>
    <pre><code>
def rabin_karp_search(text, pattern):
    d = 256  # Number of characters in the input alphabet
    q = 101  # A prime number
    m = len(pattern)
    n = len(text)
    i = 0
    j = 0
    p = 0  # hash value for pattern
    t = 0  # hash value for text
    h = 1

    # The value of h would be "pow(d, m-1)%q"
    for i in range(m - 1):
        h = (h * d) % q

    # Calculate the hash value of pattern and first window of text
    for i in range(m):
        p = (d * p + ord(pattern[i])) % q
        t = (d * t + ord(text[i])) % q

    # Slide the pattern over text one by one
    for i in range(n - m + 1):
        if p == t:  # Hash values match, check characters
            if text[i:i + m] == pattern:
                return i  # Match found at index i
        if i < n - m:
            t = (d * (t - ord(text[i]) * h) + ord(text[i + m])) % q
            if t < 0:
                t = t + q
    return -1  # No match found

# Example
text = "GEEKS FOR GEEKS"
pattern = "GEEK"
print(rabin_karp_search(text, pattern))  # Output: 0
</code></pre>
</div>

<!-- Question 65 -->
<div class="qee">
    <div class="que">
        <p>65. Implement the Sieve of Eratosthenes to find all prime numbers up to a given limit.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint65')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint65" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Create a boolean array `prime[0..n]` and initialize all entries as `True`.<br>
        2. Iterate through numbers, and for each prime number, mark its multiples as `False`.
    </div>
    <pre><code>
def sieve_of_eratosthenes(n):
    primes = [True] * (n + 1)
    primes[0], primes[1] = False, False  # 0 and 1 are not prime
    p = 2
    while p * p <= n:
        if primes[p]:
            for i in range(p * p, n + 1, p):
                primes[i] = False
        p += 1
    return [p for p in range(n + 1) if primes[p]]

# Example
n = 30
print(sieve_of_eratosthenes(n))  # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
</code></pre>
</div>

<!-- Question 66 -->
<div class="qee">
    <div class="que">
        <p>66. Implement Ford-Fulkerson Algorithm for Maximum Flow.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint66')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint66" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Implement BFS to find an augmenting path.<br>
        2. Augment the flow along the path and repeat until no more augmenting paths are found.
    </div>
    <pre><code>
from collections import deque

def bfs(capacity, source, sink, parent):
    visited = [False] * len(capacity)
    queue = deque([source])
    visited[source] = True
    while queue:
        u = queue.popleft()
        for v in range(len(capacity)):
            if not visited[v] and capacity[u][v] > 0:
                queue.append(v)
                visited[v] = True
                parent[v] = u
                if v == sink:
                    return True
    return False

def ford_fulkerson(capacity, source, sink):
    n = len(capacity)
    parent = [-1] * n
    max_flow = 0

    while bfs(capacity, source, sink, parent):
        path_flow = float('Inf')
        s = sink
        while s != source:
            path_flow = min(path_flow, capacity[parent[s]][s])
            s = parent[s]

        max_flow += path_flow

        v = sink
        while v != source:
            u = parent[v]
            capacity[u][v] -= path_flow
            capacity[v][u] += path_flow
            v = parent[v]

    return max_flow

# Example
capacity = [
    [0, 16, 13, 0, 0, 0],
    [0, 0, 10, 12, 0, 0],
    [0, 4, 0, 0, 14, 0],
    [0, 0, 9, 0, 0, 20],
    [0, 0, 0, 7, 0, 4],
    [0, 0, 0, 0, 0, 0]
]
source = 0
sink = 5
print(ford_fulkerson(capacity, source, sink))  # Output: 23
</code></pre>
</div>

<!-- Question 67 -->
<div class="qee">
    <div class="que">
        <p>67. Implement Boyer-Moore Algorithm for String Matching.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint67')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint67" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Preprocess the pattern by creating two arrays: `bad_character` and `good_suffix`.<br>
        2. Use these arrays to skip sections of the text when a mismatch occurs.
    </div>
    <pre><code>
def boyer_moore_search(text, pattern):
    def bad_character_heuristic(pattern):
        bad_char = [-1] * 256  # For all ASCII characters
        for i in range(len(pattern)):
            bad_char[ord(pattern[i])] = i
        return bad_char

    def good_suffix_heuristic(pattern):
        m = len(pattern)
        good_suffix = [m] * m
        f = [0] * m
        g = m - 1
        f[m - 1] = m
        for j in range(m - 2, -1, -1):
            if j < g:
                g = j
            f[j] = g
        return good_suffix

    bad_char = bad_character_heuristic(pattern)
    good_suffix = good_suffix_heuristic(pattern)
    n, m = len(text), len(pattern)
    i = 0
    while i <= n - m:
        j = m - 1
        while j >= 0 and pattern[j] == text[i + j]:
            j -= 1
        if j < 0:
            return i  # Match found at index i
            i += good_suffix[0] if i < n - m else 1
        else:
            i += max(good_suffix[j], j - bad_char[ord(text[i + j])])

    return -1  # No match found

# Example
text = "ABAAABCD"
pattern = "ABC"
print(boyer_moore_search(text, pattern))  # Output: 4
</code></pre>
</div>
<!-- Question 68 -->
<div class="qee">
    <div class="que">
        <p>68. Implement Top-K Elements Algorithm.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint68')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint68" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Use a heap to find the top K largest or smallest elements.<br>
        2. You can either use a min-heap or a max-heap depending on the problem's requirement.
    </div>
    <pre><code>
import heapq

def top_k_elements(arr, k):
    return heapq.nlargest(k, arr)

# Example
arr = [10, 4, 3, 50, 23, 90]
k = 3
print(top_k_elements(arr, k))  # Output: [90, 50, 23]
</code></pre>
</div>

<!-- Question 69 -->
<div class="qee">
    <div class="que">
        <p>69. Implement Bucket Sort Algorithm.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint69')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint69" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Divide the input array into several subarrays (buckets).<br>
        2. Sort each bucket individually, either using a different sorting algorithm or recursively applying bucket sort.<br>
        3. Concatenate the sorted buckets to get the final sorted result.
    </div>
    <pre><code>
def bucket_sort(arr):
    if len(arr) == 0:
        return arr

    min_value = min(arr)
    max_value = max(arr)
    bucket_range = (max_value - min_value) / len(arr)
    buckets = [[] for _ in range(len(arr))]

    for num in arr:
        index = int((num - min_value) / bucket_range)
        if index == len(arr):
            index -= 1
        buckets[index].append(num)

    for i in range(len(arr)):
        buckets[i].sort()

    sorted_arr = []
    for bucket in buckets:
        sorted_arr.extend(bucket)

    return sorted_arr

# Example
arr = [0.42, 0.32, 0.23, 0.56, 0.71, 0.12, 0.89]
print(bucket_sort(arr))  # Output: [0.12, 0.23, 0.32, 0.42, 0.56, 0.71, 0.89]
</code></pre>
</div>

<!-- Question 70 -->
<div class="qee">
    <div class="que">
        <p>70. Implement Radix Sort Algorithm.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint70')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint70" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Radix Sort processes digits from the least significant digit to the most significant digit.<br>
        2. Use a stable counting sort for each digit to ensure the order remains consistent.
    </div>
    <pre><code>
def counting_sort(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10

    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1

    for i in range(1, 10):
        count[i] += count[i - 1]

    for i in range(n - 1, -1, -1):
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1

    for i in range(n):
        arr[i] = output[i]

def radix_sort(arr):
    max_num = max(arr)
    exp = 1
    while max_num // exp > 0:
        counting_sort(arr, exp)
        exp *= 10

# Example
arr = [170, 45, 75, 90, 802, 24, 2, 66]
radix_sort(arr)
print(arr)  # Output: [2, 24, 45, 66, 75, 90, 170, 802]
</code></pre>
</div>

<!-- Question 71 -->
<div class="qee">
    <div class="que">
        <p>71. Implement Merge Sort Algorithm.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint71')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint71" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Divide the array into two halves.<br>
        2. Recursively sort the two halves.<br>
        3. Merge the two sorted halves into a single sorted array.
    </div>
    <pre><code>
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        merge_sort(left_half)
        merge_sort(right_half)

        i = j = k = 0

        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1

        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1

# Example
arr = [12, 11, 13, 5, 6, 7]
merge_sort(arr)
print(arr)  # Output: [5, 6, 7, 11, 12, 13]
</code></pre>
</div>

<!-- Question 72 -->
<div class="qee">
    <div class="que">
        <p>72. Implement Quick Sort Algorithm.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint72')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint72" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Choose a pivot element from the array.<br>
        2. Partition the array such that elements less than the pivot are on the left, and elements greater are on the right.<br>
        3. Recursively apply quicksort to the left and right parts of the array.
    </div>
    <pre><code>
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# Example
arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))  # Output: [1, 1, 2, 3, 6, 8, 10]
</code></pre>
</div>

<!-- Question 73 -->
<div class="qee">
    <div class="que">
        <p>73. Implement Heap Sort Algorithm.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint73')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint73" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Build a max-heap from the input array.<br>
        2. Swap the root of the heap with the last element and reduce the heap size.<br>
        3. Heapify the root to maintain the max-heap property.
    </div>
    <pre><code>
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[largest] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

# Example
arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
print(arr)  # Output: [5, 6, 7, 11, 12, 13]
</code></pre>
</div>
<!-- Question 74 -->
<div class="qee">
    <div class="que">
        <p>74. Implement Insertion Sort Algorithm.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint74')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint74" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start from the second element and compare it with the elements before it.<br>
        2. Shift elements that are greater than the current element to the right.<br>
        3. Insert the current element into the correct position.
    </div>
    <pre><code>
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

# Example
arr = [12, 11, 13, 5, 6]
insertion_sort(arr)
print(arr)  # Output: [5, 6, 11, 12, 13]
</code></pre>
</div>

<!-- Question 75 -->
<div class="qee">
    <div class="que">
        <p>75. Implement Selection Sort Algorithm.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint75')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint75" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start with the first element and search for the smallest element in the unsorted portion of the array.<br>
        2. Swap the smallest element with the first unsorted element.<br>
        3. Repeat for the remaining unsorted portion.
    </div>
    <pre><code>
def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

# Example
arr = [64, 25, 12, 22, 11]
selection_sort(arr)
print(arr)  # Output: [11, 12, 22, 25, 64]
</code></pre>
</div>

<!-- Question 76 -->
<div class="qee">
    <div class="que">
        <p>76. Implement Shell Sort Algorithm.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint76')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint76" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start with a gap larger than 1 (e.g., length of the array / 2).<br>
        2. Perform a gapped insertion sort for elements that are 'gap' apart.<br>
        3. Reduce the gap and repeat until the gap is 1.
    </div>
    <pre><code>
def shell_sort(arr):
    n = len(arr)
    gap = n // 2
    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap //= 2

# Example
arr = [5, 2, 9, 1, 5, 6]
shell_sort(arr)
print(arr)  # Output: [1, 2, 5, 5, 6, 9]
</code></pre>
</div>

<!-- Question 77 -->
<div class="qee">
    <div class="que">
        <p>77. Implement Counting Sort Algorithm.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint77')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint77" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Count the number of occurrences of each element.<br>
        2. Calculate the cumulative count.<br>
        3. Place elements into their correct position based on their count.
    </div>
    <pre><code>
def counting_sort(arr):
    max_val = max(arr)
    min_val = min(arr)
    range_of_elements = max_val - min_val + 1

    count = [0] * range_of_elements
    output = [0] * len(arr)

    for i in range(len(arr)):
        count[arr[i] - min_val] += 1

    for i in range(1, len(count)):
        count[i] += count[i - 1]

    for i in range(len(arr) - 1, -1, -1):
        output[count[arr[i] - min_val] - 1] = arr[i]
        count[arr[i] - min_val] -= 1

    for i in range(len(arr)):
        arr[i] = output[i]

# Example
arr = [4, 2, 2, 8, 3, 3, 1]
counting_sort(arr)
print(arr)  # Output: [1, 2, 2, 3, 3, 4, 8]
</code></pre>
</div>

<!-- Question 78 -->
<div class="qee">
    <div class="que">
        <p>78. Implement Binary Search Algorithm.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint78')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint78" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Start with the middle element of the sorted array.<br>
        2. If the target is equal to the middle element, return the index.<br>
        3. If the target is less, repeat the search in the left half. If greater, search in the right half.
    </div>
    <pre><code>
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return -1  # Element not found

# Example
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
target = 5
print(binary_search(arr, target))  # Output: 4
</code></pre>
</div>

<!-- Question 79 -->
<div class="qee">
    <div class="que">
        <p>79. Implement Fibonacci Sequence using Recursion and Iteration.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint79')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint79" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the previous two.<br>
        2. You can implement the Fibonacci sequence both recursively and iteratively.
    </div>
    <pre><code>
# Recursive approach
def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

# Iterative approach
def fibonacci_iterative(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a

# Example
print(fibonacci_recursive(6))  # Output: 8
print(fibonacci_iterative(6))  # Output: 8
</code></pre>
</div>
<!-- Question 80 -->
<div class="qee">
    <div class="que">
        <p>80. Implement the KMP Algorithm (Knuth-Morris-Pratt) for string matching.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint80')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint80" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Preprocess the pattern to create a partial match table (or LPS array).<br>
        2. Compare the pattern with the text, using the LPS array to skip unnecessary comparisons.
    </div>
    <pre><code>
def KMP(pattern, text):
    m, n = len(pattern), len(text)
    lps = [0] * m
    j = 0
    
    # Preprocessing the pattern to create LPS array
    def compute_lps(pattern):
        length = 0
        i = 1
        while i < m:
            if pattern[i] == pattern[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length - 1]
                else:
                    lps[i] = 0
                    i += 1

    compute_lps(pattern)
    
    i = 0
    while i < n:
        if pattern[j] == text[i]:
            i += 1
            j += 1
        if j == m:
            print("Pattern found at index " + str(i - j))
            j = lps[j - 1]
        elif i < n and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1

# Example
text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
KMP(pattern, text)
</code></pre>
</div>

<!-- Question 81 -->
<div class="qee">
    <div class="que">
        <p>81. Implement the Rabin-Karp Algorithm for string matching.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint81')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint81" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Calculate the hash value of the pattern and the initial substring of the text.<br>
        2. Compare the hash values of the pattern and substrings of the text.<br>
        3. If hash values match, check the actual strings.
    </div>
    <pre><code>
def rabin_karp(pattern, text):
    d = 256  # Number of characters in input alphabet
    q = 101  # A prime number
    m = len(pattern)
    n = len(text)
    p = 0  # Hash value for pattern
    t = 0  # Hash value for text
    h = 1
    
    for i in range(m - 1):
        h = (h * d) % q
    
    # Calculate the hash value of pattern and first window of text
    for i in range(m):
        p = (d * p + ord(pattern[i])) % q
        t = (d * t + ord(text[i])) % q
    
    # Slide the pattern over text one by one
    for i in range(n - m + 1):
        if p == t:
            if text[i:i + m] == pattern:
                print("Pattern found at index " + str(i))
        
        if i < n - m:
            t = (d * (t - ord(text[i]) * h) + ord(text[i + m])) % q
            if t < 0:
                t = t + q

# Example
text = "GEEKS FOR GEEKS"
pattern = "GEEKS"
rabin_karp(pattern, text)
</code></pre>
</div>

<!-- Question 82 -->
<div class="qee">
    <div class="que">
        <p>82. Implement the Sieve of Eratosthenes to find all prime numbers up to a given number.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint82')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint82" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Create a boolean array and initialize all entries as true.<br>
        2. Starting from 2, mark all multiples of the current number as false.<br>
        3. After completing the sieve, the remaining numbers marked as true are primes.
    </div>
    <pre><code>
def sieve_of_eratosthenes(n):
    primes = [True] * (n + 1)
    p = 2
    while p * p <= n:
        if primes[p]:
            for i in range(p * p, n + 1, p):
                primes[i] = False
        p += 1
    
    for p in range(2, n + 1):
        if primes[p]:
            print(p, end=" ")

# Example
n = 30
sieve_of_eratosthenes(n)
</code></pre>
</div>

<!-- Question 83 -->
<div class="qee">
    <div class="que">
        <p>83. Implement Ford-Fulkerson Algorithm to find the maximum flow in a flow network.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint83')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint83" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Use Depth-First Search (DFS) to find augmenting paths in the residual graph.<br>
        2. Increase the flow along these paths, updating the residual capacities.<br>
        3. Repeat until no more augmenting paths can be found.
    </div>
    <pre><code>
# Ford-Fulkerson Algorithm (using DFS)
def bfs(capacity, source, sink, parent):
    visited = [False] * len(capacity)
    queue = [source]
    visited[source] = True
    
    while queue:
        u = queue.pop(0)
        for v in range(len(capacity)):
            if not visited[v] and capacity[u][v] > 0:
                queue.append(v)
                visited[v] = True
                parent[v] = u
                if v == sink:
                    return True
    return False

def ford_fulkerson(capacity, source, sink):
    parent = [-1] * len(capacity)
    max_flow = 0
    
    while bfs(capacity, source, sink, parent):
        path_flow = float("Inf")
        s = sink
        while s != source:
            path_flow = min(path_flow, capacity[parent[s]][s])
            s = parent[s]
        
        max_flow += path_flow
        v = sink
        while v != source:
            u = parent[v]
            capacity[u][v] -= path_flow
            capacity[v][u] += path_flow
            v = parent[v]
    
    return max_flow

# Example
capacity = [
    [0, 16, 13, 0, 0, 0],
    [0, 0, 10, 12, 0, 0],
    [0, 4, 0, 0, 14, 0],
    [0, 0, 9, 0, 0, 20],
    [0, 0, 0, 7, 0, 4],
    [0, 0, 0, 0, 0, 0]
]

source = 0
sink = 5
print(ford_fulkerson(capacity, source, sink))  # Output: 23
</code></pre>
</div>
<!-- Question 84 -->
<div class="qee">
    <div class="que">
        <p>84. Implement the Boyer-Moore Algorithm for pattern searching in a string.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint84')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint84" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Preprocess the pattern to create two tables: one for the bad character rule and one for the good suffix rule.<br>
        2. Start comparing the pattern from the end and move it based on mismatches using the bad character rule.
    </div>
    <pre><code>
def boyer_moore(pattern, text):
    m = len(pattern)
    n = len(text)
    bad_char = [-1] * 256
    
    # Preprocessing the pattern to create the bad character table
    for i in range(m):
        bad_char[ord(pattern[i])] = i
    
    s = 0
    while s <= n - m:
        j = m - 1
        while j >= 0 and pattern[j] == text[s + j]:
            j -= 1
        
        if j < 0:
            print(f"Pattern found at index {s}")
            s += (m - bad_char[ord(text[s + m])] if s + m < n else 1)
        else:
            s += max(1, j - bad_char[ord(text[s + j])])
            
# Example
text = "ABAAABCDABAAABCD"
pattern = "ABC"
boyer_moore(pattern, text)
</code></pre>
</div>

<!-- Question 85 -->
<div class="qee">
    <div class="que">
        <p>85. Implement Top-K Elements algorithm to find the K most frequent elements in an array.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint85')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint85" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Use a frequency map (hash map) to count the occurrences of each element.<br>
        2. Use a heap or priority queue to keep track of the top K frequent elements.
    </div>
    <pre><code>
from collections import Counter
import heapq

def top_k_elements(arr, k):
    count = Counter(arr)
    heap = [(-freq, num) for num, freq in count.items()]
    heapq.heapify(heap)
    
    result = []
    for _ in range(k):
        freq, num = heapq.heappop(heap)
        result.append(num)
    
    return result

# Example
arr = [1, 1, 1, 2, 2, 3, 3, 3, 3]
k = 2
print(top_k_elements(arr, k))  # Output: [3, 1]
</code></pre>
</div>

<!-- Question 86 -->
<div class="qee">
    <div class="que">
        <p>86. Implement Bucket Sort algorithm to sort an array.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint86')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint86" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Divide the range of the numbers into several buckets.<br>
        2. Sort each bucket individually, and then concatenate the results.
    </div>
    <pre><code>
def bucket_sort(arr):
    if len(arr) == 0:
        return arr
    
    # Find the maximum value in the array
    max_val = max(arr)
    size = max_val / len(arr)
    
    # Create empty buckets
    buckets = [[] for _ in range(len(arr))]
    
    # Distribute the elements into buckets
    for i in range(len(arr)):
        index = int(arr[i] / size)
        if index != len(arr):
            buckets[index].append(arr[i])
        else:
            buckets[len(arr) - 1].append(arr[i])
    
    # Sort each bucket and concatenate
    result = []
    for i in range(len(arr)):
        result.extend(sorted(buckets[i]))
    
    return result

# Example
arr = [0.42, 0.32, 0.23, 0.52, 0.37, 0.43]
print(bucket_sort(arr))  # Output: [0.23, 0.32, 0.37, 0.42, 0.43, 0.52]
</code></pre>
</div>

<!-- Question 87 -->
<div class="qee">
    <div class="que">
        <p>87. Implement Radix Sort algorithm to sort an array of integers.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint87')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint87" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Sort the numbers starting from the least significant digit to the most significant.<br>
        2. Use counting sort as a subroutine to sort the numbers based on each digit.
    </div>
    <pre><code>
def counting_sort(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10
    
    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1
    
    for i in range(1, 10):
        count[i] += count[i - 1]
    
    i = n - 1
    while i >= 0:
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1
    
    for i in range(n):
        arr[i] = output[i]

def radix_sort(arr):
    max_val = max(arr)
    exp = 1
    while max_val // exp > 0:
        counting_sort(arr, exp)
        exp *= 10

# Example
arr = [170, 45, 75, 90, 802, 24, 2, 66]
radix_sort(arr)
print(arr)  # Output: [2, 24, 45, 66, 75, 90, 170, 802]
</code></pre>
</div>

<!-- Question 88 -->
<div class="qee">
    <div class="que">
        <p>88. Implement Merge Sort algorithm to sort an array.</p>
        <div class="btn">
            <button type="button" onclick="showHint('hint88')">Show Hint</button>
            <button type="button" class="try"> <a href="try.html" target=_blank>Try Here</a></button>
        </div>
    </div>
    <!-- Hidden Hint -->
    <div id="hint" data-hint="hint88" style="display: none; margin-top: 10px; color: #555;">
        Hint:<br>
        1. Divide the array into two halves.<br>
        2. Recursively sort both halves.<br>
        3. Merge the two sorted halves into a single sorted array.
    </div>
    <pre><code>
def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m
    
    L = arr[l:l + n1]
    R = arr[m + 1:m + 1 + n2]
    
    i = j = 0
    k = l
    while i < n1 and j < n2:
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
    
    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1
    
    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1

def merge_sort(arr, l, r):
    if l < r:
        m = (l + r) // 2
        merge_sort(arr, l, m)
        merge_sort(arr, m + 1, r)
        merge(arr, l, m, r)

# Example
arr = [12, 11, 13, 5, 6, 7]
merge_sort(arr, 0, len(arr) - 1)
print(arr)  # Output: [5, 6, 7, 11, 12, 13]
</code></pre>
</div>



 <!-- Navigation Buttons -->
 <div class="btn-container">
  <button type="button" onclick="previousQuestion()">Previous</button>
  <button type="button" onclick="nextQuestion()">Next</button>
</div>
       </div>
       </div>
       </div>
       </body>
       </html>